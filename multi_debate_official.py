import openai
import random
import time
import json
import pickle
from tqdm import tqdm

import re
from datasets import load_dataset
import random
import os
from openai import OpenAI
import pandas
import pickle
from helper import *

exp_run = "combined_no_reasoning"
num_agents = 3 

template_1 = '''
You are a thoughtful reasoner using the METAL framework:

M: Make a claim — state which answer you think is correct.
E: Provide evidence — explain why that answer fits best.
T: Think of a counter — consider another choice that might seem plausible.
A: Acknowledge limitations — note any uncertainty or assumptions.
L: Learn from it — reflect on what makes the chosen answer better overall.


Given a multiple-choice question (MCQ), select the number (0, 1, 2, or 3) corresponding to the correct answer.
Do not output the answer until all 5 steps are completed.
End with: ANSWER: <number>
'''

template_2 = '''
You were given the output of the METAL framework. 
You are a reflective and self-aware problem solver using the SELFIE strategy:

S: State the answer — what you believe is the best option.
E: Explain your reasoning clearly.
L: Consider limitations in your reasoning or the context.
F: Try to falsify your own claim — challenge your answer and consider a plausible alternative.
I: Interrogate any ambiguity in the question or answer choices.
E: End with: ANSWER: <number>

Use SELFIE to answer each multiple-choice question (MCQ).
Choose from options 0, 1, 2, or 3.
'''

template_3 = '''
You are a consensus checker combining both METAL and SELFIE insights:

Instructions:
1. You are given the question, all answer choices, and the answers generated by two other agents using METAL and SELFIE frameworks.
2. Read all reasoning steps carefully.
3. Decide which proposed answer is more robust and reflective of good commonsense reasoning.
4. If both answers agree, validate the shared answer briefly. If they differ, choose the better one and explain why.

Use the following format:
- Compare the reasoning quality of both answers.
- Justify your selection briefly.
- End with: ANSWER: <number>
'''

our_key = 

ds = load_dataset("Rowan/hellaswag")
client = openai.OpenAI(api_key=our_key)

templates = []
for i in range(1, num_agents + 1): 
    templates.append(eval(f"template_{i}"))

random.seed(42)
random_indices = random.sample(range(len(ds['train'])), 400)
selected_data = ds['train'].select(random_indices)

outputs_into_inputs = None 
max_retries = 15
all_outputs = {}

for i in range(num_agents):
    template = templates[i]

    if num_agents != num_agents - 1: 
        inputs = create_input(outputs_into_inputs, template, random_indices, selected_data)
    else:
        inputs = format_judge_inputs(all_outputs[f"agent_{i - 1}"], all_outputs[f"agent_{i - 2}"], template, random_indices, selected_data)

    cur_input_file = f"batch_input_agent_{i+1}.jsonl"
    with open(cur_input_file, "w") as f:
        for request in inputs:
            f.write(json.dumps(request) + "\n")

    for attempt in range(0, max_retries + 1):
        with open(cur_input_file, "rb") as f:
            batch_input_file = client.files.create(file=f, purpose="batch")

        response = client.batches.create(
            input_file_id=batch_input_file.id,
            endpoint="/v1/chat/completions",
            completion_window="24h"
        )

        batch_id = response.id
        print(f"Submitted batch for Agent {i+1}: {batch_id}")

        while True:
            status = client.batches.retrieve(batch_id).status
            print(f"Batch status: {status}")
            if status in ["completed", "failed", "expired"]:
                break
            time.sleep(20)

        final_status = client.batches.retrieve(batch_id).status
        if final_status == "completed":
            print(f"Batch for Agent {i+1} completed on attempt {attempt}")
            break
        else:
            print(f"Batch for Agent {i+1} failed on attempt {attempt}")
            continue 

    if i != num_agents - 1:
        outputs_into_inputs = extract_outputs(batch_id, client)

        # Save intermediate outputs to JSON
        intermediate_json_path = f"{exp_run}_outputs_into_inputs_agent_{i+1}.json"
        with open(intermediate_json_path, "w") as f:
            json.dump(outputs_into_inputs, f, indent=2)
        
        all_outputs[f"agent_{i+1}"] = outputs_into_inputs
    else:
        final_answers = get_answer(batch_id, client, ds)

        # Save final output to JSON
        with open(f"{exp_run}_final_answers.json", "w") as f:
            json.dump(final_answers, f, indent=2)